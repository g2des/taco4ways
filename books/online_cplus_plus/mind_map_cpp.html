<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.23.0/themes/prism.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.5/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.3"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.5/dist/index.umd.min.js"></script><script>(r => {
                setTimeout(r);
              })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"heading","d":1,"p":{"lines":[0,1]},"v":"C++ Tutorial","c":[{"t":"heading","d":2,"p":{"lines":[2,3]},"v":"Structure of a program","c":[{"t":"heading","d":3,"p":{"lines":[4,5]},"v":"Directive","c":[{"t":"list_item","d":5,"p":{"lines":[5,7]},"v":"Lines beginning with a hash sign (#) are directives read and interpreted by what is known as the preprocessor. They are special lines interpreted before the compilation of the program itself<br>\nbegins."},{"t":"list_item","d":5,"p":{"lines":[7,8]},"v":"The directive <code>#include &lt;iostream&gt;</code>, instructs the preprocessor to include a section of standard C++ code, known as header iostream, that allows to perform standard input and output operations."},{"t":"list_item","d":5,"p":{"lines":[8,9]},"v":"Preprocessor directives (those that begin by #) are out of this general rule since they are not statements."},{"t":"list_item","d":5,"p":{"lines":[9,10]},"v":"They are lines read and processed by the preprocessor before proper compilation begins."},{"t":"list_item","d":5,"p":{"lines":[10,11]},"v":"Preprocessor directives must be specified in their own line and, because they are not statements, do not have to end with a semicolon (;)."}]},{"t":"heading","d":3,"p":{"lines":[13,14]},"v":"Statements:","c":[{"t":"list_item","d":5,"p":{"lines":[15,16]},"v":"A <strong>statement</strong> is an expression that can actually produce some effect."},{"t":"list_item","d":5,"p":{"lines":[16,17]},"v":"It is the meat of a program, specifying its actual behavior."},{"t":"list_item","d":5,"p":{"lines":[17,18]},"v":"Statements are executed in the same order that they appear within a function's body."}]}]},{"t":"heading","d":2,"p":{"lines":[19,20]},"v":"Variables and types","c":[{"t":"bullet_list","d":3,"p":{"lines":[21,23]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[21,22]},"v":"Variables are portion of memorty to store values."}]},{"t":"blockquote","d":3,"p":{"lines":[23,24]},"v":"","c":[{"t":"paragraph","d":4,"p":{"lines":[23,24]},"v":"Note that other than char (which has a size of exactly one byte), none of the fundamental types has a standard size specified (but a minimum size, at most). Therefore, the type is not required (and in many cases is not) exactly this minimum size. This does not mean that these types are of an undetermined size, but that there is no standard size across all compilers and machines; each compiler implementation may specify the sizes for these types that fit the best the architecture where the program is going to run. This rather generic size specification for types gives the C++ language a lot of flexibility to be adapted to work optimally in all kinds of platforms, both present and future."}]},{"t":"bullet_list","d":3,"p":{"lines":[25,34]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[25,26]},"v":"The properties of fundamental types in a particular system and compiler implementation can be obtained by using the <a href=\"https://www.cplusplus.com/numeric_limits\">numeric_limits</a> classes (see standard header <code>&lt;limits&gt;</code>)."},{"t":"list_item","d":4,"p":{"lines":[27,28]},"v":"<strong>Declaration of variable:</strong> C++ is a strongly-typed language, and requires every variable to be declared with its type before its first use. This informs the compiler the size to reserve in memory for the variable and how to interpret its value. The syntax to declare a new variable in C++ is straightforward: we simply write the type followed by the variable name (i.e., its identifier)."},{"t":"list_item","d":4,"p":{"lines":[29,30]},"v":"<strong>Initialization of variable:</strong> In C++, there are three ways to initialize variables.","c":[{"t":"list_item","d":6,"p":{"lines":[30,31],"index":1},"v":"1. The first one, known as c-like initialization (because it is inherited from the C language), consists of appending an equal sign followed by the value to which the variable is initialized."},{"t":"list_item","d":6,"p":{"lines":[31,32],"index":2},"v":"2. Second method, known as constructor initialization (introduced by the C++ language), encloses the initial value between parentheses (<strong>()</strong>)."},{"t":"list_item","d":6,"p":{"lines":[32,33],"index":3},"v":"3. Third method, known as uniform initialization, similar to the above, but using curly braces (<strong>{}</strong>) instead of parentheses (this was introduced by the revision of the C++ standard, in 2011)."}]}]},{"t":"heading","d":3,"p":{"lines":[34,35]},"v":"Type deduction: <code>auto</code> and <code>decltype</code>","c":[{"t":"bullet_list","d":4,"p":{"lines":[35,45]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[35,36]},"v":"When a new variable is initialized, the compiler can figure out what the type of the variable is automatically by the initializer. For this, it suffices to use auto as the type specifier for the variable."},{"t":"list_item","d":5,"p":{"lines":[40,41]},"v":"Variables that are <strong>not initialized</strong> can also make use of type deduction with the decltype specifier."}]},{"t":"blockquote","d":4,"p":{"lines":[45,46]},"v":"","c":[{"t":"paragraph","d":5,"p":{"lines":[45,46]},"v":"<code>auto</code> and <code>decltype</code> are powerful features recently added to the language. But the type deduction features they introduce are meant to be used either when the type cannot be obtained by other means or when using it improves code readability."}]}]},{"t":"heading","d":3,"p":{"lines":[47,48]},"v":"Introduction to strings","c":[{"t":"list_item","d":5,"p":{"lines":[48,49]},"v":"A first difference with fundamental data types is that in order to declare and use objects (variables) of this type, the program needs to include the header where the type is defined within the standard library (<code>#include &lt;string&gt;</code>)."}]}]},{"t":"heading","d":2,"p":{"lines":[50,51]},"v":"Constants","c":[{"t":"bullet_list","d":3,"p":{"lines":[51,53]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[51,52]},"v":"Constants are expression with fixed values."}]},{"t":"heading","d":3,"p":{"lines":[53,54]},"v":"Literals","c":[{"t":"list_item","d":5,"p":{"lines":[54,55]},"v":"Used to express particular value within the program. In <code>a = 5</code>, 5 is a literal constant."},{"t":"list_item","d":5,"p":{"lines":[55,56]},"v":"Several string literals can be concatenated to form a single string literal simply by separating them by one or more blank spaces, including tabs, newlines, and other valid blank characters."},{"t":"list_item","d":5,"p":{"lines":[56,57]},"v":"Some programmers also use a trick to include long string literals in multiple lines: In C++, a backslash (\\) at the end of line is considered a line-continuation character that merges both that line and the next into a single line."}]},{"t":"heading","d":3,"p":{"lines":[58,59]},"v":"Preprocessor definitions (<code>#define</code>)","c":[{"t":"bullet_list","d":4,"p":{"lines":[59,63]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[59,60]},"v":"They have the following form: <code>#define identifier replacement</code>"},{"t":"list_item","d":5,"p":{"lines":[60,61]},"v":"After this directive, any occurrence of <code>identifier</code> in the code is interpreted as <code>replacement</code>, where <code>replacement</code> is any sequence of characters (until the end of the line)."},{"t":"list_item","d":5,"p":{"lines":[61,62]},"v":"This replacement is <strong>performed by the preprocessor, and happens before the program is compiled, thus causing a sort of blind replacement: the validity of the types or syntax involved is not checked in any way.</strong>"}]},{"t":"blockquote","d":4,"p":{"lines":[63,64]},"v":"","c":[{"t":"paragraph","d":5,"p":{"lines":[63,64]},"v":"Note that the <code>#define</code> lines are preprocessor directives, and as such are single-line instructions that -unlike C++ statements- do not require semicolons (;) at the end; the directive extends automatically until the end of the line. If a semicolon is included in the line, it is part of the replacement sequence and is also included in all replaced occurrences.##"}]}]}]},{"t":"heading","d":2,"p":{"lines":[65,66]},"v":"Operators","c":[{"t":"heading","d":3,"p":{"lines":[66,67]},"v":"Comma Operator","c":[{"t":"list_item","d":5,"p":{"lines":[67,68]},"v":"The comma operator (,) is used to separate two or more expressions that are included where only one expression is expected."},{"t":"list_item","d":5,"p":{"lines":[68,69]},"v":"When the set of expressions has to be evaluated for a value, only the right-most expression is considered."},{"t":"list_item","d":5,"p":{"lines":[69,70]},"v":"For example, the following code: <code>int a = (b=3, b+2)</code> would first assign the value 3 to b, and then assign b+2 to variable a. So, at the end, variable a would contain the value 5 while variable b would contain value 3."}]}]},{"t":"heading","d":2,"p":{"lines":[71,72]},"v":"Basic Input/Output","c":[{"t":"bullet_list","d":3,"p":{"lines":[72,73]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[72,73]},"v":"C++ uses a convenient abstraction called streams to perform input and output operations in sequential media such as the screen, the keyboard or a file."}]},{"t":"blockquote","d":3,"p":{"lines":[73,74]},"v":"","c":[{"t":"paragraph","d":4,"p":{"lines":[73,74]},"v":"The <code>endl</code> manipulator produces a newline character, exactly as the insertion of '\\n' does; but <strong>it also has an additional behavior: the stream's buffer (if any) is flushed, which means that the output is requested to be physically written to the device, if it wasn't already.</strong> This affects mainly fully buffered streams, and cout is (generally) not a fully buffered stream. Still, it is generally a good idea to use <code>endl</code> only when flushing the stream would be a feature and '\\n' when it would not. <strong>Bear in mind that a flushing operation incurs a certain overhead, and on some devices it may produce a delay.</strong>"}]},{"t":"heading","d":3,"p":{"lines":[75,76]},"v":"cin","c":[{"t":"bullet_list","d":4,"p":{"lines":[76,83]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[76,77]},"v":"<code>cin</code>  method has a big drawback. What happens in the example above <strong>if the user enters something else that cannot be interpreted as an integer? Well, in this case, the extraction operation fails. And this, by default, lets the program continue without setting a value for variable i, producing undetermined results if the value of i is used later.</strong>"},{"t":"list_item","d":5,"p":{"lines":[77,78]},"v":"<code>cin</code> extraction always considers spaces (whitespaces, tabs, new-line...) as terminating the value being extracted, and thus extracting a string means to always extract a single word, not a phrase or an entire sentence."},{"t":"list_item","d":5,"p":{"lines":[78,79]},"v":"To get an entire line from <code>cin</code>, there exists a function, called <code>getline</code>, that takes the stream (<code>cin</code>) as first argument, and the string variable as second."}]},{"t":"blockquote","d":4,"p":{"lines":[83,84]},"v":"","c":[{"t":"paragraph","d":5,"p":{"lines":[83,84]},"v":"The standard behavior that most users expect from a console program is that each time the program queries the user for input, the user introduces the field, and then presses ENTER (or RETURN). That is to say, input is generally expected to happen in terms of lines on console programs, and this can be achieved by using getline to obtain input from the user. Therefore, unless you have a strong reason not to, you should always use getline to get input in your console programs instead of extracting from cin."}]}]},{"t":"heading","d":3,"p":{"lines":[85,86]},"v":"stringstream","c":[{"t":"bullet_list","d":4,"p":{"lines":[87,90]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[87,88]},"v":"The standard header <code>&lt;sstream&gt;</code> defines a type called <code>stringstream</code> that allows a string to be treated as a stream, and thus allowing extraction or insertion operations from/to strings in the same way as they are performed on <code>cin</code> and <code>cout</code>."},{"t":"list_item","d":5,"p":{"lines":[88,89]},"v":"This feature is most useful to convert strings to numerical values and vice versa."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;sstream&gt;\n#include &lt;string&gt;\n\nusing namespace std;\n\nint main(){\n    string mystr;\n    int price;\n\n    cout &lt;&lt; &quot;Enter price:&quot;;\n    getline(cin, mystr);\n    stringstream(mystr) &gt;&gt; price;\n    cout&lt;&lt; &quot;Price entered &quot; &lt;&lt; price;\n}\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[107,111]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[107,108]},"v":"In this example, we acquire numeric values from the standard input indirectly: Instead of extracting numeric values directly from <code>cin</code>, we get lines from it into a string object (mystr), and then we extract the values from this string into the variables price."},{"t":"list_item","d":5,"p":{"lines":[108,109]},"v":"Once these are numerical values, arithmetic operations can be performed on them, such as multiplying them to obtain a total price."},{"t":"list_item","d":5,"p":{"lines":[109,110]},"v":"With this approach of getting entire lines and extracting their contents, <strong>we separate the process of getting user input from its interpretation as data, allowing the input process to be what the user expects, and at the same time gaining more control over the transformation of its content into useful data by the program.</strong>"}]}]}]},{"t":"heading","d":2,"p":{"lines":[111,112]},"v":"Functions","c":[{"t":"heading","d":3,"p":{"lines":[112,113]},"v":"Arguments passed by value and by reference","c":[{"t":"bullet_list","d":4,"p":{"lines":[113,115]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[113,114]},"v":"<strong>Passed by value</strong>: When calling a function, what is passed to the function are the values of these arguments on the moment of the call, which are copied into the variables represented by the function parameters."},{"t":"list_item","d":5,"p":{"lines":[114,115]},"v":"In certain cases, though, it may be useful to access an external variable from within a function. To do that, arguments can be <strong>passed by reference</strong>, instead of by value."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nvoid duplicate(int&amp; a, int&amp; b){\n    a *=2;\n    b *=2;\n}\n\nint main(){\n    int x, y;\n    x=3;\n    y=4;\n    duplicate(x, y);\n    cout&lt;&lt; x &lt;&lt;y;\n    return 0;\n}\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[133,136]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[133,134]},"v":"To gain access to its arguments, the function declares its parameters as references."},{"t":"list_item","d":5,"p":{"lines":[134,135]},"v":"When a variable is <strong>passed by reference</strong>, what is passed is no longer a copy, but the variable itself, the variable identified by the function parameter, becomes somehow associated with the argument passed to the function, and any modification on their corresponding local variables within the function are reflected in the variables passed as arguments in the call."}]}]},{"t":"heading","d":3,"p":{"lines":[136,137]},"v":"Efficiency consideration and <code>const</code> references","c":[{"t":"bullet_list","d":4,"p":{"lines":[137,141]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[137,138]},"v":"Functions with reference parameters are generally perceived as functions that modify the arguments passed, because that is why reference parameters are actually for."},{"t":"list_item","d":5,"p":{"lines":[138,139]},"v":"The solution is for the function to guarantee that its reference parameters are not going to be modified by this function. This can be done by qualifying the parameters as constant."},{"t":"list_item","d":5,"p":{"lines":[139,140]},"v":"By qualifying them as <code>const</code>, the function is forbidden to modify the values of neither a nor b, but can actually access their values as references (aliases of the arguments), without having to make actual copies of the strings."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">string concatenate(const string&amp; a, const string&amp; b){\n    return a+b;\n}\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[147,149]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[147,148]},"v":"Therefore, <code>const</code> references provide functionality similar to passing arguments by value, but with an increased efficiency for parameters of large types. That is why they are extremely popular in C++ for arguments of compound types."}]}]},{"t":"heading","d":3,"p":{"lines":[149,150]},"v":"Inline functions","c":[{"t":"bullet_list","d":4,"p":{"lines":[150,153]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[150,151]},"v":"Calling a function generally causes a certain overhead (stacking arguments, jumps, etc...), and thus for very short functions, it may be more efficient to simply insert the code of the function where it is called, instead of performing the process of formally calling a function."},{"t":"list_item","d":5,"p":{"lines":[151,152]},"v":"Preceding a function declaration with the inline specifier informs the compiler that inline expansion is preferred over the usual function call mechanism for a specific function."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">inline string concatenate(const string&amp; a, const string&amp; b){\n    return a+b;\n}\n</code></pre>\n"},{"t":"blockquote","d":4,"p":{"lines":[158,159]},"v":"","c":[{"t":"paragraph","d":5,"p":{"lines":[158,159]},"v":"Note that most compilers already optimize code to generate inline functions when they see an opportunity to improve efficiency, even if not explicitly marked with the inline specifier. Therefore, this specifier merely indicates the compiler that inline is preferred for this function, although the compiler is free to not inline it, and optimize otherwise."}]}]},{"t":"heading","d":3,"p":{"lines":[160,161]},"v":"Default values in parameters","c":[{"t":"list_item","d":5,"p":{"lines":[161,162]},"v":"In C++, functions can also have optional parameters, for which no arguments are required in the call, in such a way that, for example, a function with three parameters may be called with only two."},{"t":"list_item","d":5,"p":{"lines":[162,163]},"v":"Once default value is used for an argument in function definition, all subsequent arguments to it must have default value. It can also be stated as default arguments are assigned from right to left."}]},{"t":"heading","d":3,"p":{"lines":[164,165]},"v":"Declaring functions","c":[{"t":"list_item","d":5,"p":{"lines":[165,166]},"v":"Functions cannot be called before they are declared."},{"t":"list_item","d":5,"p":{"lines":[166,167]},"v":"The prototype of a function can be declared without actually defining the function completely, giving just enough details to allow the types involved in a function call to be known."},{"t":"list_item","d":5,"p":{"lines":[167,168]},"v":"The parameter list does not need to include the parameter names, but only their types. Parameter names can nevertheless be specified, but they are optional, and do not need to necessarily match those in the function definition."}]}]},{"t":"heading","d":2,"p":{"lines":[169,170]},"v":"Function overloading and templates","c":[{"t":"heading","d":3,"p":{"lines":[171,172]},"v":"Overloading","c":[{"t":"list_item","d":5,"p":{"lines":[172,173]},"v":"In C++, two different functions can have the same name if their parameters are different; either because they have a different number of parameters, or because any of their parameters are of a different type."},{"t":"list_item","d":5,"p":{"lines":[173,174]},"v":"A function cannot be overloaded only by its return type. At least one of its parameters must have a different type."}]},{"t":"heading","d":3,"p":{"lines":[175,176]},"v":"Function templates","c":[{"t":"bullet_list","d":4,"p":{"lines":[176,180]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[176,177]},"v":"The function sum could be overloaded for a lot of types, and it could make sense for all of them to have the same body. For cases such as this, C++ has the ability to define functions with generic types, known as <strong>function templates</strong>."},{"t":"list_item","d":5,"p":{"lines":[177,178]},"v":"Defining a function template follows the same syntax as a regular function, except that it is preceded by the template keyword and a series of template parameters enclosed in angle-brackets <code>&lt;&gt;</code>:<code>template &lt;template-parameters&gt; function-declaration</code>"},{"t":"list_item","d":5,"p":{"lines":[178,179]},"v":"Instantiating a template is applying the template to create a function using particular types or values for its template parameters. This is done by calling the function template, with the same syntax as calling a regular function, but specifying the template arguments enclosed in angle brackets: <code>name &lt;template-arguments&gt; (function-arguments)</code>"},{"t":"list_item","d":5,"p":{"lines":[179,180]},"v":"In this specific case where the generic type T is used as a parameter for sum, the compiler is even able to deduce the data type automatically without having to explicitly specify it within angle brackets. It is possible to instead simply write without the type enclosed in angle brackets."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\ntemplate &lt;class T&gt;\nT sum(T a, T b){\n    T result;\n    result = a + b;\n    return result;\n}\n\ntemplate &lt;class T, int mul&gt;\nT scale(T a){\n    return a*mul;\n}\n\nint main(){\n    cout &lt;&lt; sum&lt;int&gt;(1,2)&lt;&lt;endl;\n    cout &lt;&lt; sum(2.0, 3.99)&lt;&lt;endl; // type implicitly identified \n    cout &lt;&lt; scale&lt;int,2&gt;(1)&lt;&lt;endl;\n    cout &lt;&lt; scale&lt;int, 3&gt;(3.99)&lt;&lt;endl;\n    // why does this return double?\n    // This returns double because the declations inside the angle\n    // brackets have one to one correspondence to the variables defined\n    // in the template.\n    cout &lt;&lt; scale&lt;double, 3&gt;(3.99)&lt;&lt;endl; \n    // this should return double, even if the params are non double.\n    cout&lt;&lt; scale&lt;double, 3&gt;(3)&lt;&lt;endl;\n    return 0;\n}\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[212,213]},"v":"Non-type template arguments","c":[{"t":"list_item","d":5,"p":{"lines":[213,214]},"v":"The template parameters can not only include types introduced by class or typename, but can also include expressions of a particular type"},{"t":"list_item","d":5,"p":{"lines":[214,215]},"v":"<strong>But there exists a major difference: the value of template parameters is determined on compile-time to generate a different instantiation of the function fixed_multiply, and thus the value of that argument is never passed during runtime</strong>"}]}]},{"t":"heading","d":2,"p":{"lines":[216,217]},"v":"Namespaces","c":[{"t":"bullet_list","d":3,"p":{"lines":[218,225]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[218,219]},"v":"Only one entity can exist with a particular name in a particular scope."},{"t":"list_item","d":4,"p":{"lines":[219,220]},"v":"But non-local names bring more possibilities for name collision, especially considering that libraries may declare many functions, types, and variables, neither of them local in nature, and some of them very generic."},{"t":"list_item","d":4,"p":{"lines":[220,221]},"v":"Namespaces allow us to group named entities that otherwise would have global scope into narrower scopes, giving them namespace scope."},{"t":"list_item","d":4,"p":{"lines":[221,222]},"v":"The keyword <code>using</code> introduces a name into the current declarative region (such as a block), thus avoiding the need to qualify the name."},{"t":"list_item","d":4,"p":{"lines":[222,223]},"v":"<code>using</code> and <code>using namespace</code> have validity only in the same block in which they are stated or in the entire source code file if they are used directly in the global scope."},{"t":"list_item","d":4,"p":{"lines":[223,224]},"v":"Existing namespaces can be <strong>aliased with new names</strong>, with the following syntax: <code>namespace new_name = current_name;</code>"}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\nnamespace normal{\n    const double pi = 3.14;\n    double area(int r){\n        return pi * r * r;\n    } \n}\n\nnamespace morePrecision{\n    const double pi = 3.1415;\n    double area(int r){\n        return pi  * r * r;\n    }\n}\nint main(){\n    //Method 1: Explicit declaration for all \n    cout &lt;&lt; normal::area(10) &lt;&lt; endl;\n    cout &lt;&lt; morePrecision::area(10) &lt;&lt; endl;\n    //Method 2: Declare one with `using`\n    using normal::area;\n    cout &lt;&lt; area(10) &lt;&lt; endl;\n    cout &lt;&lt; morePrecision::area(10) &lt;&lt; endl;\n    //Method 3: Each in ints block\n    {\n        using normal::area;\n        cout &lt;&lt; area(10) &lt;&lt; endl;\n    }\n    {\n        using morePrecision::area;\n        cout &lt;&lt; area(10) &lt;&lt; endl;\n    }\n}\n</code></pre>\n"},{"t":"heading","d":3,"p":{"lines":[260,261]},"v":"Storage classes","c":[{"t":"list_item","d":5,"p":{"lines":[261,262]},"v":"<strong>The storage for variables with global or namespace scope is allocated for the entire duration of the program.</strong>"},{"t":"list_item","d":5,"p":{"lines":[262,263]},"v":"This is known as static storage, and it contrasts with the storage for local variables (those declared within a block). These use what is known as automatic storage."},{"t":"list_item","d":5,"p":{"lines":[263,264]},"v":"But there is another substantial difference between variables with static storage and variables with automatic storage:","c":[{"t":"list_item","d":7,"p":{"lines":[264,265]},"v":"Variables with static storage (such as global variables) that are not explicitly initialized are automatically initialized to zeroes."},{"t":"list_item","d":7,"p":{"lines":[265,266]},"v":"Variables with automatic storage (such as local variables) that are not explicitly initialized are left uninitialized, and thus have an undetermined value."}]}]}]},{"t":"heading","d":2,"p":{"lines":[267,268]},"v":"Arrays","c":[{"t":"bullet_list","d":3,"p":{"lines":[268,274]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[268,269]},"v":"Contiguous memory location described as <code>type name[elements]</code>, where type in valid data type, name is a valid identifier and elements is a constant expression, defining the length of the array."},{"t":"list_item","d":4,"p":{"lines":[269,270]},"v":"Can be initialized to specific values, enclosed in {}."},{"t":"list_item","d":4,"p":{"lines":[270,271]},"v":"The number of values between braces {} shall not be greater than the number of elements in the array. If declared with less, the remaining elements are set to their default values (which for fundamental types, means they are filled with zeroes)."},{"t":"list_item","d":4,"p":{"lines":[271,272]},"v":"With the only difference that with multidimensional arrays, the compiler automatically remembers the depth of each imaginary dimension."},{"t":"list_item","d":4,"p":{"lines":[272,273]},"v":"In the code above, the first parameter (<code>int arg[]</code>) accepts any array whose elements are of type int, whatever its length."},{"t":"list_item","d":4,"p":{"lines":[273,274]},"v":"For multidimensional array as argument could be:  <code>void procedure(int myarray[][3][4])</code>"}]},{"t":"blockquote","d":3,"p":{"lines":[274,275]},"v":"","c":[{"t":"paragraph","d":4,"p":{"lines":[274,275]},"v":"Notice that the first brackets [] are left empty, while the following ones specify sizes for their respective dimensions. This is necessary in order for the compiler to be able to determine the depth of each additional dimension."}]},{"t":"bullet_list","d":3,"p":{"lines":[275,277]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[275,276]},"v":"Above step does not allow reshaping of array just by simply parameter declaration."}]}]},{"t":"heading","d":2,"p":{"lines":[277,278]},"v":"Character sequences","c":[{"t":"bullet_list","d":3,"p":{"lines":[278,281]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[278,279]},"v":"Strings are, in fact, sequences of characters, we can represent them also as plain arrays of elements of a character type."},{"t":"list_item","d":4,"p":{"lines":[279,280]},"v":"Because string literals are regular arrays, they have the same restrictions as these, and cannot be assigned values."},{"t":"list_item","d":4,"p":{"lines":[280,281]},"v":"However, this issue is resolved by using string class instead of char array."}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\n#include &lt;string&gt;\nusing namespace std;\n\nint main(){\n    char test[] = &quot;This is a text&quot;;\n    // test = &quot;this is a test&quot;; generates invalid array assignment error\n    // test[] = &quot;this is another array&quot;; generates error based on length\n    string text = &quot;This is a string&quot;;\n    text = &quot;This is another string&quot;; // Works just fine.\n\n}\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[295,297]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[295,296]},"v":"String literals still always produce null-terminated character sequences, and not <code>class string</code> objects."}]}]},{"t":"heading","d":2,"p":{"lines":[297,298]},"v":"Pointers","c":[{"t":"bullet_list","d":3,"p":{"lines":[298,304]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[298,299]},"v":"A variable which stores the address of another variable is called a pointer."},{"t":"list_item","d":4,"p":{"lines":[299,300]},"v":"The reference and dereference operators are thus complementary:","c":[{"t":"list_item","d":6,"p":{"lines":[300,301]},"v":"&amp; is the address-of operator, and can be read simply as &quot;address of&quot;"},{"t":"list_item","d":6,"p":{"lines":[301,302]},"v":"* is the dereference operator, and can be read as &quot;value pointed to by&quot;"}]},{"t":"list_item","d":4,"p":{"lines":[302,303]},"v":"Due to the ability of a pointer to directly refer to the value that it points to, a pointer has different properties when it points to a char than when it points to an int or a float."}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">...\nint numbers[5];\nint * p;\np = numbers;  *p = 10;\np++;  *p = 20;\np = &amp;numbers[2];  *p = 30;\np = numbers + 3;  *p = 40;\np = numbers;  *(p+4) = 50;\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[314,316]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[314,315]},"v":"Brackets ([]) were explained as specifying the index of an element of the array. Well, in fact these brackets are a dereferencing operator known as offset operator."},{"t":"list_item","d":4,"p":{"lines":[315,316]},"v":"When pointers are initialized, what is initialized is the address they point to (i.e., myptr), never the value being pointed (i.e., <code>*myptr</code>). Therefore, the code above shall not be confused with:"}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">int myvar;\nint * myptr;\n*myptr = &amp;myvar;\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[321,324]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[321,322]},"v":"Which anyway would not make much sense (and is not valid code)."},{"t":"list_item","d":4,"p":{"lines":[322,323]},"v":"The asterisk (*) in the pointer declaration (line 2) <strong>only indicates that it is a pointer, it is not the dereference operator (as in line 3)</strong>. Both things just happen to use the same sign: *."},{"t":"list_item","d":4,"p":{"lines":[323,324]},"v":"It is also possible to declare pointers that can access the pointed value to read it, but not to modify it. For this, it is enough with qualifying the type pointed to by the pointer as <code>const</code>."}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">...\nint x;\nint *p1 = &amp;x;               // non-const pointer to non-const int\nconst int *p2 = &amp;x;         // non-const pointer to const int\nint * const p3 = &amp;x;        // const pointer to non-const int\nconst int * const p4 = &amp;x;  // const pointer to const int \n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[332,336]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[332,333]},"v":"<code>void pointers</code> are pointers that point to a value that has no type (and thus also an undetermined length and undetermined dereferencing properties)."},{"t":"list_item","d":4,"p":{"lines":[333,334]},"v":"This gives void pointers a great flexibility, by being able to point to any data type, from an integer value or a float to a string of characters."},{"t":"list_item","d":4,"p":{"lines":[334,335]},"v":"They have a great limitation: the data pointed to by them cannot be directly dereferenced."},{"t":"list_item","d":4,"p":{"lines":[335,336]},"v":"<code>nullptr</code> can be expressed in C++ in two ways: either with an integer value of zero, or with the nullptr keyword."}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">...\nint *a =0;// Null pointer\nint *b = nullptr; \n...\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[342,343]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[342,343]},"v":"Pointers to functions are declared with the same syntax as a regular function declaration, except that the name of the function is enclosed between parentheses () and an asterisk (*) is inserted before the name"}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#include &lt;iostream&gt;\nusing namespace std;\n\nint addition(int a, int b){return a+b;}\nint minus(int a, int b){return a-b};\n\nint operation(int a, int b, int (*func_to_call)(int, int)){\n    int g;\n    g = (*func_to_call)(a, b);\n    return g;\n}\n\nint main(){\n    int (*subtraction)(int, int) = minus;\n    int m = operation(5, 4, addition);\n    int n = operation(20, m, subtraction);\n    cout &lt;&lt; n &lt;&lt;endl;\n    return 0; \n}\n</code></pre>\n"}]},{"t":"heading","d":2,"p":{"lines":[365,366]},"v":"Dynamic memory allocation","c":[{"t":"list_item","d":4,"p":{"lines":[366,367]},"v":"Dynamic memory is allocated using operator <code>new</code>."},{"t":"list_item","d":4,"p":{"lines":[367,368]},"v":"<code>new</code> is followed by a data type specifier and, if a sequence of more than one element is required, the number of these within brackets []."},{"t":"list_item","d":4,"p":{"lines":[368,369]},"v":"C++ provides two standard mechanisms to check if the allocation was successful:","c":[{"t":"list_item","d":6,"p":{"lines":[369,370]},"v":"One is by handling exceptions. Using this method, an exception of type bad_alloc is thrown when the allocation fails."},{"t":"list_item","d":6,"p":{"lines":[370,371]},"v":"The other method is known as nothrow, and what happens when it is used is that when a memory allocation fails, instead of throwing a bad_alloc exception or terminating the program, the pointer returned by new is a null pointer, and the program continues its execution normally. <code>foo = new (nothrow) int [5];</code>"}]},{"t":"list_item","d":4,"p":{"lines":[371,372]},"v":"<code>delete</code> to release memory block. <code>delete pointer; delete[] pointer;</code>"}]},{"t":"heading","d":2,"p":{"lines":[373,374]},"v":"Datastructures","c":[{"t":"bullet_list","d":3,"p":{"lines":[374,377]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[374,375]},"v":"A data structure is a group of data elements grouped together under one name."},{"t":"list_item","d":4,"p":{"lines":[375,376]},"v":"These data elements, known as members, can have different types and different lengths."}]},{"t":"heading","d":3,"p":{"lines":[377,378]},"v":"Structs","c":[{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">struct type_name {\nmember_type1 member_name1;\nmember_type2 member_name2;\nmember_type3 member_name3;\n.\n.\n} object_names;\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[387,388]},"v":"Typedef","c":[{"t":"list_item","d":5,"p":{"lines":[388,389]},"v":"A type alias is a different name by which a type can be identified."},{"t":"list_item","d":5,"p":{"lines":[389,390]},"v":"Syntax : <code>typedef existing_type new_type_name ;</code> or <code>using new_type_name = existing_type ;</code>"},{"t":"list_item","d":5,"p":{"lines":[390,391]},"v":"They are most useful as tools <strong>to abstract programs from the underlying types they use.</strong> For example, by using an alias of int to refer to a particular kind of parameter instead of using int directly, it allows for the type to be easily replaced by long (or some other type) in a later version, without having to change every instance where it is used."}]},{"t":"heading","d":3,"p":{"lines":[392,393]},"v":"Unions","c":[{"t":"bullet_list","d":4,"p":{"lines":[393,396]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[393,394]},"v":"Unions allow one portion of memory to be accessed as different data types."},{"t":"list_item","d":5,"p":{"lines":[394,395]},"v":"<strong>One of the uses of a union is to be able to access a value either in its entirety or as an array or structure of smaller elements. Ex. Flags, accessed individually or set to a value directly, like in chmod +x and 7 can both be used</strong>"},{"t":"list_item","d":5,"p":{"lines":[395,396]},"v":"When unions are members of a class (or structure), they can be declared with no name. In this case, they become anonymous unions, and its members are directly accessible from objects by their member names."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">struct book1_t {\n  char title[50];\n  char author[50];\n  union {\n    float dollars;\n    int yen;\n  } price;\n} book1;\n// usage book1.price.dollars;\nstruct book1_t {\n  char title[50];\n  char author[50];\n  union {\n    float dollars;\n    int yen;\n  };\n} book2;\n// usage book2.dollars;\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[417,418]},"v":"Enumerated with enum","c":[{"t":"bullet_list","d":4,"p":{"lines":[418,419]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[418,419]},"v":"Enumerated types are types that are defined with a set of custom identifiers, known as enumerators, as possible values."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">enum colors_t {black, blue, green, cyan, red, purple, yellow, white};\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[422,424]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[422,423]},"v":"The elements of such an enum are always assigned an integer numerical equivalent internally, to which they can be implicitly converted to."},{"t":"list_item","d":5,"p":{"lines":[423,424]},"v":"A specific integer value can be specified for any of the possible values in the enumerated type. And if the constant value that follows it is itself not given its own value, it is automatically assumed to be the same value plus one."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">enum months_t { january=1, february, march, april,\n                may, june, july, august,\n                september, october, november, december} y2k;\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[430,431]},"v":"Enumerated with enum class","c":[{"t":"bullet_list","d":4,"p":{"lines":[431,432]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[431,432]},"v":"It is possible to create real enum types that are neither implicitly convertible to int and that neither have enumerator values of type int, but of the enum type itself, thus preserving type safety."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">Colors mycolor;\n \nmycolor = Colors::blue;\nif (mycolor == Colors::green) mycolor = Colors::red; \n\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[439,440]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[439,440]},"v":"Enumerated types declared with enum class also have more control over their underlying type : <code>enum class EyeColor : char {blue, green, brown};</code>"}]}]}]},{"t":"heading","d":2,"p":{"lines":[442,443]},"v":"Classes","c":[{"t":"bullet_list","d":3,"p":{"lines":[443,450]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[443,444]},"v":"Classes are an expanded concept of data structures: like data structures, they can contain data members, but they can also contain functions as members."},{"t":"list_item","d":4,"p":{"lines":[444,445]},"v":"An object is an instantiation of a class. In terms of variables, a class would be the type, and an object would be the variable."},{"t":"list_item","d":4,"p":{"lines":[445,446]},"v":"By default, all members of a class declared with the class keyword have private access for all its members."},{"t":"list_item","d":4,"p":{"lines":[446,447]},"v":"The way of calling constructors by enclosing their arguments in parentheses, as shown above, is known as functional form :  <code>class_type obj_name(...)</code>"},{"t":"list_item","d":4,"p":{"lines":[447,448]},"v":"Constructors with a single parameter can be called using the variable initialization syntax (an equal sign followed by the argument): <code>class_name object_name = initialization_value;</code>"},{"t":"list_item","d":4,"p":{"lines":[448,449]},"v":"Uniform initialization : <code>class_name object_name { value, value, value, ... }</code>"},{"t":"list_item","d":4,"p":{"lines":[449,450]},"v":"An advantage of uniform initialization over functional form is that, unlike parentheses, braces cannot be confused with function declarations, and thus can be used to explicitly call default constructors"}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">...\nCircle {} // default constructor\nCircle {10} // parametrized constructor\n...\n</code></pre>\n"},{"t":"heading","d":3,"p":{"lines":[457,458]},"v":"Member initialization in constructors","c":[{"t":"bullet_list","d":4,"p":{"lines":[458,461]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[458,459]},"v":"When a constructor is used to initialize other members, these other members can be initialized directly, without resorting to statements in its body."},{"t":"list_item","d":5,"p":{"lines":[459,460]},"v":"For members of fundamental types, it makes no difference which of the ways above the constructor is defined, because they are not initialized by default, but for member objects (those whose type is a class), if they are not initialized after the colon, they are default-constructed."},{"t":"list_item","d":5,"p":{"lines":[460,461]},"v":"In some other cases, default-construction is not even possible (when the class does not have a default constructor). In these cases, members shall be initialized in the member initialization list."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">// member initialization\n...\nclass Cylinder {\n    Circle base;\n    double height;\n  public:\n    Cylinder(double r, double h) : base (r), height(h) {}\n    double volume() {return base.area() * height;}\n};\n...\n\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[475,476]},"v":"Pointers to class","c":[{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">...\nRectangle obj (3, 4);\nRectangle * foo, * bar, * baz;\nfoo = &amp;obj;\nbar = new Rectangle (5, 6);\nbaz = new Rectangle[2] { {2,5}, {3,6} };\n...\ndelete bar;\ndelete[] baz;\n...\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[488,489]},"v":"Overloading operators","c":[{"t":"blockquote","d":4,"p":{"lines":[490,491]},"v":"","c":[{"t":"paragraph","d":5,"p":{"lines":[490,491]},"v":"Classes, essentially, define new types to be used in C++ code. And types in C++ not only interact with code by means of constructions and assignments. They also interact by means of operators."}]},{"t":"bullet_list","d":4,"p":{"lines":[492,495]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[492,493]},"v":"C++ allows most operators to be overloaded so that their behavior can be defined for just about any type, including classes."},{"t":"list_item","d":5,"p":{"lines":[493,494]},"v":"Syntax : <code>type operator sign (parameters) { /*... body ...*/ }</code>"},{"t":"list_item","d":5,"p":{"lines":[494,495]},"v":"The function <code>operator+</code> of class CVector overloads the addition operator (+) for that type. Once declared, this function can be called either implicitly using the operator, or explicitly using its functional name:"}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">c = a + b;\nc = a.operator+ (b);\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[499,501]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[499,500]},"v":"The parameter expected for a member function overload for operations such as operator+ is naturally the operand to the right hand side of the operator."}]}]},{"t":"heading","d":3,"p":{"lines":[501,502]},"v":"this keyword","c":[{"t":"list_item","d":5,"p":{"lines":[502,503]},"v":"The keyword <code>this</code> represents a pointer to the object whose member function is being executed."}]},{"t":"heading","d":3,"p":{"lines":[504,505]},"v":"Static members","c":[{"t":"list_item","d":5,"p":{"lines":[505,506]},"v":"Static members have the same properties as non-member variables but they enjoy class scope. For that reason, and to avoid them to be declared several times, they cannot be initialized directly in the class, but need to be initialized somewhere outside it."}]},{"t":"heading","d":3,"p":{"lines":[507,508]},"v":"<code>const</code> member functions","c":[{"t":"list_item","d":5,"p":{"lines":[508,509]},"v":"When an object of a class is qualified as a <code>const</code> object:The access to its data members from outside the class is restricted to read-only, as if all its data members were const for those accessing them from outside the class."},{"t":"list_item","d":5,"p":{"lines":[509,510]},"v":"The member functions of a <code>const</code> object can only be called if they are themselves specified as <code>const</code> members."},{"t":"list_item","d":5,"p":{"lines":[510,511]},"v":"Member functions specified to be const cannot modify non-static data members nor call other non-const member functions. In essence, const members shall not modify the state of an object."},{"t":"list_item","d":5,"p":{"lines":[511,512]},"v":"Most functions taking classes as parameters actually take them by const reference, and thus, these functions can only access their const members,"}]},{"t":"heading","d":3,"p":{"lines":[513,514]},"v":"Class templates","c":[{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">template &lt;class T&gt;\nclass mypair {\n    T pair[2];\n    mypair(T first, T second){\n        pair[0] = first;\n        pair[1] = second;\n    }\n}\n</code></pre>\n"}]},{"t":"heading","d":3,"p":{"lines":[524,525]},"v":"Template specialization","c":[{"t":"bullet_list","d":4,"p":{"lines":[525,526]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[525,526]},"v":"It is possible to define a different implementation for a template when a specific type is passed as template argument. This is called a template specialization."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++ // template specialization\"><code class=\"language-C++ // template specialization\">#include &lt;iostream&gt;\nusing namespace std;\n\n// class template:\ntemplate &lt;class T&gt;\nclass mycontainer {\n    T element;\n  public:\n    mycontainer (T arg) {element=arg;}\n    T increase () {return ++element;}\n};\n\n// class template specialization:\ntemplate &lt;&gt;\nclass mycontainer &lt;char&gt; {\n    char element;\n  public:\n    mycontainer (char arg) {element=arg;}\n    char uppercase ()\n    {\n      if ((element&gt;='a')&amp;&amp;(element&lt;='z'))\n      element+='A'-'a';\n      return element;\n    }\n};\n\n</code></pre>\n"}]}]},{"t":"heading","d":2,"p":{"lines":[555,556]},"v":"Friends, inheritance and polymorphism","c":[{"t":"bullet_list","d":3,"p":{"lines":[556,558]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[556,557]},"v":"In principle, private and protected members of a class cannot be accessed from outside the same class in which they are declared."},{"t":"list_item","d":4,"p":{"lines":[557,558]},"v":"A non-member function can access the private and protected members of a class if it is declared a friend of that class."}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">class Rectangle {\n    // ...\n    friend Rectangle duplicate (const Rectangle&amp;);\n    // ...\n};\nRectangle duplicate (const Rectangle&amp; param)\n{\n  Rectangle res;\n  res.width = param.width*2;\n  res.height = param.height*2;\n  return res;\n}\nint main () {\n  Rectangle foo;\n  Rectangle bar (2,3);\n  foo = duplicate (bar);\n  cout &lt;&lt; foo.area() &lt;&lt; '\\n';\n  return 0;\n}\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[579,581]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[579,580]},"v":"Derived class syntax for inheritance: <code>class derived_class_name: public base_class_name { /*...*/ };</code>"}]},{"t":"heading","d":3,"p":{"lines":[581,582]},"v":"Virtual members","c":[{"t":"bullet_list","d":4,"p":{"lines":[582,583]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[582,583]},"v":"A virtual member is a member function that can be redefined in a derived class, while preserving its calling properties through references."}]},{"t":"fence","d":4,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">class Polygon{\n    // ...\n    virtual int area (){ return 0; }\n    // ...     \n}\n</code></pre>\n"},{"t":"bullet_list","d":4,"p":{"lines":[590,593]},"v":"","c":[{"t":"list_item","d":5,"p":{"lines":[590,591]},"v":"Classes that contain at least one pure virtual function are known as abstract base classes."},{"t":"list_item","d":5,"p":{"lines":[591,592]},"v":"Pure virtual class syntax : <code>virtual int area () =0;</code>"}]}]}]},{"t":"heading","d":2,"p":{"lines":[593,594]},"v":"Typecasting","c":[{"t":"bullet_list","d":3,"p":{"lines":[594,599]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[594,595]},"v":"For non-fundamental types, arrays and functions implicitly convert to pointers, and pointers in general allow the following conversions:","c":[{"t":"list_item","d":6,"p":{"lines":[595,596]},"v":"Null pointers can be converted to pointers of any type"},{"t":"list_item","d":6,"p":{"lines":[596,597]},"v":"Pointers to any type can be converted to void pointers."},{"t":"list_item","d":6,"p":{"lines":[597,598]},"v":"Pointer upcast: pointers to a derived class can be converted to a pointer of an accessible and unambiguous base class, without modifying its const or volatile qualification."}]},{"t":"list_item","d":4,"p":{"lines":[598,599]},"v":"Implicit conversion within classes:"}]},{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">class A {};\n\nclass B {\npublic:\n  // conversion from A (constructor): aka single argument constructor\n  B (const A&amp; x) {}\n  // explicit version\n  explicit B (const A&amp; x) {} \n  \n  // conversion from A (assignment): aka assignment operator\n  B&amp; operator= (const A&amp; x) {return *this;}\n  // conversion to A (type-cast operator) aka typecasting\n  operator A() {return A();}\n};\n\nint main ()\n{\n  A foo;\n  B bar = foo;    // calls constructor; throws error for explicit\n  B bar (foo);\n  bar = foo;      // calls assignment\n  foo = bar;      // calls type-cast operator\n  return 0;\n}\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[625,633]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[625,626]},"v":"On a function call, C++ allows one implicit conversion to happen for each argument. This may be somewhat problematic for classes, because it is not always what is intended. It can be prevented by marking the affected constructor with the <code>explicit</code> keyword"},{"t":"list_item","d":4,"p":{"lines":[627,628]},"v":"In order to control unrestricted explicit type-casting , we have four specific casting operators:","c":[{"t":"list_item","d":6,"p":{"lines":[628,629]},"v":"dynamic_cast : upcasts and downcasts only if can point to complete object. Returns nullptr if cannot convert successfully."},{"t":"list_item","d":6,"p":{"lines":[629,630]},"v":"static_cast : upcasts and downcasts without any evaluations. Onus of working is on programmer."},{"t":"list_item","d":6,"p":{"lines":[630,631]},"v":"reinterpret_cast : Cast any pointer to any other pointer."},{"t":"list_item","d":6,"p":{"lines":[631,632]},"v":"const_cast : manipulates constantness of the object pointed by the pointer."}]}]}]},{"t":"heading","d":2,"p":{"lines":[633,634]},"v":"Preprocessors","c":[{"t":"fence","d":3,"v":"<pre class=\"language-C++\"><code class=\"language-C++\">#define getmax(a,b) a&gt;b?a:b \n\n#define TABLE_SIZE 100\nint table1[TABLE_SIZE];\n#undef TABLE_SIZE\n\n#define str(x) #x\ncout &lt;&lt; str(test); // equivalent to cout &lt;&lt; &quot;test&quot;\n</code></pre>\n"},{"t":"bullet_list","d":3,"p":{"lines":[644,647]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[644,645]},"v":"<code>#include &lt;header&gt;</code>: This is used to include headers provided by the implementation, such as the headers that compose the standard library (iostream, string,...)."},{"t":"list_item","d":4,"p":{"lines":[645,646]},"v":"<code>#include &quot;header&quot;</code>: The syntax used in the second #include uses quotes, and includes a file. The file is searched for in an implementation-defined manner, which generally includes the current path. In the case that the file is not found, the compiler interprets the directive as a header inclusion."}]}]}]})</script>
</body>
</html>
